```
inline fun TextView.addTextChangedListenerClosure(
    crossinline afterTextChanged: (Editable?) -> Unit = {},
    crossinline beforeTextChanged: (CharSequence?, Int, Int, Int) -> Unit = { charSequence, start, count, after -> },
    crossinline onTextChanged: (CharSequence?, Int, Int, Int) -> Unit = { charSequence, start, after, count -> }
) {
    val listener = object : TextWatcher {
        override fun afterTextChanged(s: Editable?) {
            afterTextChanged.invoke(s)
        }

        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {
            beforeTextChanged.invoke(s, start, count, after)
        }

        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {
            onTextChanged.invoke(s, start, before, count)
        }
    }
    this.addTextChangedListener(listener)
}

```

我们创建一个同名扩展函数，使用 Closure 尾缀作为区分，该函数的参数为与接口方法一一对应的 Kotlin 函数对象，并给其默认值赋值为 {} 即空实现，在函数体里通过 object 关键字构建匿名内部类实现对象，在其接口方法实现中调用与之一一对应的 Kotlin 函数对象。

使用方式上与普通的 Kotlin 高阶函数使用方式相同：
```
etString.addTextChangedListenerClosure(
    afterTextChanged = {
        if (it.toString().length >= 4) {
            KeyboardUtils.toggleSoftInput()
        }
    },
)

```

上面示例的扩展函数中，我们使用了 inline 与 crossinline 两个关键字，这是 Koltin 特有的。inline 关键字通常用于修饰高阶函数，用于提升性能。crossinline 声明的 lambda 不允许局部返回，用于避免调用者错误的使用 return 导致函数中断。

提供一个示例代码，亲自尝试一下也许可以更好的理解：
```
@Test
fun testInline() {
    testClosure {
        return
    }
}
private inline fun testClosure(test: (String) -> String ) {
    println("step 1")
    println(test("step test"))
    println("step 2")
}

```

[参考](https://blog.csdn.net/u011133887/article/details/123004000)