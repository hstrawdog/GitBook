# 混合 

image3 = cv.addWeighted(image1,0.7,image2,0.3,0)

# 缩放

- 绝对缩放

  cv.resize(kids,(2*cols, 2* rows))

- 相对缩放

  cv.resize(kids, None,fx=0.5,fy=0.5)
  
  fx  fy  缩放因子 (比例)

# 平移

1. 设置平移位置矩阵

   x 移动100 y移动50

   M= np.float32([[1,0,100],[0,1,50]])

2. 根据矩阵重新绘制

   res2= cv.warpAffine(kids, M ,(cols, rows))

# 旋转

1. 设置旋转矩阵

   旋转点 , 角度, 缩放  注意是先缩放再旋转

   M = cv.getRotationMatrix2D((cols/2, rows/2), 90, 1)

2. 根据矩阵重新绘制

   res3= cv.warpAffine(kids,M,(cols,rows))

# 翻转

- cv.flip(src, flipCode )

  -  flipCode  0 上下
  -  flipCode >1  左右
  -  flipCode <0 上下+ 左右
  
  
  

# 仿射变换



- 什么是仿射变换

  平移缩放移动的 总称

- 提供3个点生成矩阵

- warpAffine(src,M dsize, flags , mode, value)
  - M  变换矩阵
  -  dsize 变化大小
  
- 例子1

  ```
  #变换前的点
  pls1= np.float32([[50,50],[200,50],[50,200]])
  # 变换后的点
  pls2= np.float32([[100,100], [200,50],[100,250]])
  # 生成 反射矩阵
  M = cv.getAffineTransform(pls1,pls2)
  # 变换绘制
  res4 = cv.warpAffine(kids, M, (cols,rows))
  ```

- 例子2

  另外一种矩阵生成方式

  ```
  import cv2 as cv
  
  dog = cv.imread("./image/dog.jpeg")
  
  #  生成矩阵  仿射变换
  h, w, ch = dog.shape
  #  生成矩阵
  M = cv.getRotationMatrix2D((w / 2, h / 2), 15, 1.0)
  #  变换
  new =cv.warpAffine(dog,M,(w,h))
  cv.imshow("dog",dog)
  cv.imshow("new",new)
  cv.waitKey(0)
  
  ```

# 透视变换

应用	作业识别改错用 

- 需要提供4个点的坐标

```
# 导入头文件
import numpy as np 
import cv2 as cv 
import matplotlib.pyplot as plt

# 加载图片
kids =cv.imread("./image/kids.jpg")
# 读取 行列
rows,cols = kids.shape[:2]

# 原图点
pst1=np.float32([[56,65],[368,52],[28,387],[389,390 ]])
# 透视后的点
pst2=np.float32([[100,145],[300,100],[80,290],[310,300 ]])
# 生成透视矩阵
M =cv.getPerspectiveTransform(pst1,pst2)

# 根据矩阵生成图片 
dst= cv.warpPerspective(kids, M , (cols,rows))

# 显示图片
plt.imshow(dst[:,:,::-1])


```



# 图形金字塔

- 上采样 cv.pyrUp

  

- 下采样 cv.pyrDown

  

​	有点像是放大缩小











